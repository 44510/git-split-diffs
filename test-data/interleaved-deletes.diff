commit 171b655e8abfa368f4a6c7c2b1352ea04375ae7f
Author: nickreid <nickreid@google.com>
Date:   Wed Mar 13 18:48:45 2019 -0700

    Stop attempting type inference on object-rest and object-spread; just call them `Object`s.
    
    This decision was made because:
      - There are some known bugs with the existing inference
      - It was determined that correct inference is not possible in all cases
      - The complexity of better inference was more expensive than it's worth
        - Evidence the lack of special support for `Object.assign`
    
    -------------
    Created by MOE: https://github.com/google/moe
    MOE_MIGRATED_REVID=238356436

diff --git a/src/com/google/javascript/jscomp/TypeCheck.java b/src/com/google/javascript/jscomp/TypeCheck.java
index 0ed5cebe2..4281b6f6e 100644
--- a/src/com/google/javascript/jscomp/TypeCheck.java
+++ b/src/com/google/javascript/jscomp/TypeCheck.java
@@ -994,16 +994,29 @@ public final class TypeCheck implements NodeTraversal.Callback, CompilerPass {
   }
 
   private void checkSpread(Node spreadNode) {
-    if (spreadNode.getParent().isObjectLit()) {
-      // Nothing to check for object spread, anything can be spread.
-      return;
-    }
+    Node target = spreadNode.getOnlyChild();
+    ensureTyped(target);
+    JSType targetType = getJSType(target);
 
-    Node iterableNode = spreadNode.getOnlyChild();
-    ensureTyped(iterableNode);
-    JSType iterableType = getJSType(iterableNode);
-    validator.expectAutoboxesToIterable(
-        iterableNode, iterableType, "Spread operator only applies to Iterable types");
+    switch (spreadNode.getParent().getToken()) {
+      case OBJECTLIT:
+        // Case: `var x = {A: a, B: b, ...obj}`.
+        // Nothing to check about object spread.
+        break;
+
+      case ARRAYLIT:
+      case CALL:
+      case NEW:
+        // Case: `var x = [a, b, ...itr]`
+        // Case: `var x = fn(a, b, ...itr)`
+        validator.expectAutoboxesToIterable(
+            target, targetType, "Spread operator only applies to Iterable types");
+        break;
+
+      default:
+        throw new IllegalStateException(
+            "Unexpected parent of SPREAD: " + spreadNode.getParent().toStringTree());
+    }
   }
 
   private void checkTypeofString(Node n, String s) {
